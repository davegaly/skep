//------------------------------------------------------
// THIS FILE IS AUTOGENERATED
// DO NOT APPLY MANUAL MODIFICATIONS IN THIS FILE!
//------------------------------------------------------

const sqlite3 = require("sqlite3").verbose();
const uuid = require('uuid');
const dbHelper = require('../../../../helpers/dbManager');
const logger = require('../../../../helpers/logger');

async function getIdByGuid(guid) {
    logger.log("departmentsProvider->getIdByGuid called with guid " + guid);
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        const result = await new Promise((resolve, reject) => {
            db.serialize(() => {
                db.get(`SELECT id FROM departments WHERE guid=? LIMIT 1`, [guid], (error, row) => {
                    if (error) {
                        logger.error("departmentsProvider->getIdByGuid SQL Error: " + error.message);
                        return reject(error);
                    }

                    if (row) {
                        logger.log("departmentsProvider->getIdByGuid returned row obj " + JSON.stringify(row));
                        resolve(row.id);
                    } else {
                        logger.log("departmentsProvider->getIdByGuid record not found");
                        resolve(null);
                    }
                });
            });
        });
        db.close();
        return result;
    } catch (error) {
        logger.error("departmentsProvider->getIdByGuid error: " + error.message);
        throw error;
    }
}


// getByGuid
async function getByGuid(params) {
    logger.log("departmentsProvider->getByGuid Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        const result = await new Promise((resolve, reject) => {
            let resultObject = {};
            logger.log("departmentsProvider->getByGuid Started with params: " + JSON.stringify(params));

            db.serialize(() => {
                db.each(`SELECT * FROM departments WHERE guid=? AND id IS NOT NULL AND isDeleted=0`, [params.guid,],
                    (error, row) => {
                        if (error) {
                            logger.error(error.message);
                            return reject(error);
                        }
                        let recordToReturn = 				{
					id: row.id,
					guid: row.guid,
					name: row.name,
					altroCampo: row.altroCampo,
					dataInizio: row.dataInizio,
				};
                        resultObject = recordToReturn; // Since it's a single result, we overwrite resultObject
                    },
                    (err) => {
                        if (err) {
                            logger.error(err.message);
                            return reject(err);
                        }
                        logger.log("departmentsProvider->getByGuid Finished (Promise resolved)");
                        resolve(resultObject);
                    }
                );
            });
        });
        db.close();
        logger.log("departmentsProvider->getByGuid this is the result: " + JSON.stringify(result));
        return result;
    } catch (error) {
        logger.error("departmentsProvider->getByGuid error: " + error.message);
        throw error;
    }
}


// listForGrid
async function listForGrid(params) {
    logger.log("departmentsProvider->listForGrid Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        const result = await new Promise((resolve, reject) => {
            let resultsArray = [];
            logger.log("departmentsProvider->listForGrid Started with params: " + JSON.stringify(params));
            db.serialize(() => {
                db.each(`SELECT * FROM departments WHERE isDeleted=0`, [],
                    (error, row) => {
                        if (error) {
                            logger.error(error.message);
                            return reject(error);
                        }
                        let recordToReturn = 				{
					guid: row.guid,
					name: row.name,
				};
                        resultsArray.push(recordToReturn);
                    },
                    (err) => {
                        if (err) {
                            logger.error(err.message);
                            return reject(err);
                        }
                        logger.log("departmentsProvider->listForGrid Finished (Promise resolved)");
                        resolve(resultsArray);
                    }
                );
            });
        });
        db.close();
        logger.log("departmentsProvider->listForGrid this is the result: " + JSON.stringify(result));
        return result;
    } catch (error) {
        logger.error("departmentsProvider->listForGrid error: " + error.message);
        throw error;
    }
}


// listForDropdown
async function listForDropdown(params) {
    logger.log("departmentsProvider->listForDropdown Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        const result = await new Promise((resolve, reject) => {
            let resultsArray = [];
            logger.log("departmentsProvider->listForDropdown Started with params: " + JSON.stringify(params));
            db.serialize(() => {
                db.each(`SELECT * FROM departments WHERE isDeleted=0`, [],
                    (error, row) => {
                        if (error) {
                            logger.error(error.message);
                            return reject(error);
                        }
                        let recordToReturn = 				{
					guid: row.guid,
					name: row.name,
				};
                        resultsArray.push(recordToReturn);
                    },
                    (err) => {
                        if (err) {
                            logger.error(err.message);
                            return reject(err);
                        }
                        logger.log("departmentsProvider->listForDropdown Finished (Promise resolved)");
                        resolve(resultsArray);
                    }
                );
            });
        });
        db.close();
        logger.log("departmentsProvider->listForDropdown this is the result: " + JSON.stringify(result));
        return result;
    } catch (error) {
        logger.error("departmentsProvider->listForDropdown error: " + error.message);
        throw error;
    }
}


// listAll
async function listAll(params) {
    logger.log("departmentsProvider->listAll Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        const result = await new Promise((resolve, reject) => {
            let resultsArray = [];
            logger.log("departmentsProvider->listAll Started with params: " + JSON.stringify(params));
            db.serialize(() => {
                db.each(`SELECT * FROM departments `, [],
                    (error, row) => {
                        if (error) {
                            logger.error(error.message);
                            return reject(error);
                        }
                        let recordToReturn = 				{
					id: row.id,
					guid: row.guid,
					name: row.name,
					altroCampo: row.altroCampo,
					dataInizio: row.dataInizio,
					isDeleted: row.isDeleted,
				};
                        resultsArray.push(recordToReturn);
                    },
                    (err) => {
                        if (err) {
                            logger.error(err.message);
                            return reject(err);
                        }
                        logger.log("departmentsProvider->listAll Finished (Promise resolved)");
                        resolve(resultsArray);
                    }
                );
            });
        });
        db.close();
        logger.log("departmentsProvider->listAll this is the result: " + JSON.stringify(result));
        return result;
    } catch (error) {
        logger.error("departmentsProvider->listAll error: " + error.message);
        throw error;
    }
}


// save
async function save(params) {
    logger.log("departmentsProvider->save Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        if (params.id > 0) {
            // Update existing record
            await new Promise((resolve, reject) => {
                db.serialize(() => {
                    logger.log("departmentsProvider->save(update) Started");
                    db.prepare(`UPDATE departments SET name=?,altroCampo=?,dataInizio=? WHERE id=?`, [params.name,params.altroCampo,params.dataInizio,params.id])
                      .run((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                      })
                      .finalize((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                          resolve();
                      });
                });
            });
            logger.log("departmentsProvider->save(update) Finished");
        } else {
            // Insert new record
            await new Promise((resolve, reject) => {
                db.serialize(() => {
                    logger.log("departmentsProvider->save(insert) Started");
                    const uniqueUUID = uuid.v4();
                    logger.log("departmentsProvider->save Generated guid for new record: " + uniqueUUID);
                    db.prepare(`INSERT INTO departments (name,altroCampo,dataInizio,guid,isDeleted) VALUES (?,?,?,?,?)`, [params.name,params.altroCampo,params.dataInizio, uniqueUUID, 0])
                      .run((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                      })
                      .finalize((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                          resolve();
                      });
                });
            });
            logger.log("departmentsProvider->save(insert) Finished");
        }
        db.close();
        return "ok";
    } catch (error) {
        logger.error("departmentsProvider->save error: " + error.message);
        throw error;
    }
}


// logic delete
async function deleteLogic(params) {
    logger.log("departmentsProvider->deleteLogic Started: " + JSON.stringify(params));
    try {
        const db = await new sqlite3.Database(dbHelper.ReturnDBPath());
        if (params.guid != null && params.guid !== '') {
            await new Promise((resolve, reject) => {
                db.serialize(() => {
                    logger.log("departmentsProvider->deleteLogic(logic delete) Started");

                    db.prepare(`UPDATE departments SET isDeleted=1 WHERE guid=?`, [params.guid])
                      .run((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                      })
                      .finalize((err) => {
                          if (err) {
                              logger.error(err.message);
                              return reject(err);
                          }
                          resolve();
                      });
                });
            });
            db.close();
            logger.log("departmentsProvider->deleteLogic(logic delete) Finished");
            return "ok";
        } else {
            throw new Error("Invalid GUID");
        }
    } catch (error) {
        logger.error("departmentsProvider->deleteLogic error: " + error.message);
        throw error;
    }
}




module.exports = { getIdByGuid,getByGuid,listForGrid,listForDropdown,listAll,save,deleteLogic, }